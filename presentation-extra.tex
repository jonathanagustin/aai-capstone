\documentclass[aspectratio=169]{beamer}

% Modern theme & fonts with T1 encoding
\usetheme{metropolis}
\usefonttheme{professionalfonts}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{bookmark}

% Metropolis adjustments
\metroset{progressbar=none}
\setbeamertemplate{footline}{}

% Colors and frame title formatting
\setbeamercolor{normal text}{fg=black,bg=white}
\setbeamercolor{background canvas}{bg=white}
\setbeamercolor{frametitle}{fg=black, bg=white}

% Center frame titles
\makeatletter
\setbeamertemplate{frametitle}{
  \nointerlineskip%
  \begin{beamercolorbox}[wd=\paperwidth, sep=0.3cm, center]{frametitle}%
    \usebeamerfont{frametitle}\insertframetitle\par%
    \if\insertframesubtitle\relax%
    \else%
      \vspace{0.5em}%
      {\usebeamerfont{framesubtitle}\insertframesubtitle\par}%
    \fi%
  \end{beamercolorbox}%
}
\makeatother

% Packages
\usepackage{graphicx}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    bookmarksnumbered=true
}
\usepackage{etoolbox}
\usepackage{media9}
\usepackage{menukeys}
\usepackage{minted}

% Title and metadata
\title{Developer Life Hacks}
\subtitle{Hidden Features, Pro Tips, and Time-Saving Tricks}
\author{Jonathan Agustin}
\date{\today}

% Video filenames
\newcommand{\VideoGitHub}{video_github.mp4}
\newcommand{\VideoVSCode}{video_vscode.mp4}
\newcommand{\VideoCopilot}{video_copilot.mp4}
\newcommand{\VideoDirenv}{video_direnv.mp4}
\newcommand{\VideoTask}{video_task.mp4}
\newcommand{\VideoPrecommit}{video_precommit.mp4}

\begin{document}

%------------------------------------------------------------
% Title Slide (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Before we dive into our machine learning pipeline presentations, let’s take a step back. The real challenge often isn’t building the model—it’s handling all those little tasks around coding, reviewing, deploying, and maintaining your code. This video is all about developer experience—or DX—and the tricks and tools that can save you hours of work, reduce frustration, and help you code smarter, not harder.
%%% VOICEOVER OFF
\maketitle

%------------------------------------------------------------
% GitHub Slides (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Let’s start with where your code often lives: GitHub. Most people use GitHub daily but miss out on some hidden gems.
%
% First trick: While viewing any file in a GitHub repo, press the period key (.). Instantly, GitHub transforms into a lightweight web-based editor. Perfect for quick edits or code reviews—no need to clone locally just to tweak a line or fix a comment.
%
% For more powerful operations, try the GitHub CLI, gh. With gh you can create pull requests, view issues, and merge PRs right from your terminal. For example, gh pr create walks you through opening a new pull request without leaving your coding environment. This keeps you in the zone, saving precious context-switching time.
%%% VOICEOVER OFF
\begin{frame}{GitHub Hacks}
\begin{itemize}
\item Press \keys{.} for instant web editor
\item Use GitHub CLI \keys{gh} for PRs/issues/merges in terminal
\item Minimal context switching, improved flow
\end{itemize}
\vspace{0.3em}
\end{frame}

% GitHub Video (VO ~30s)
\begin{frame}{GitHub Demo}
\centering
\IfFileExists{\VideoGitHub}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoGitHub,
  flashvars={
    source=\VideoGitHub&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% VS Code Slides (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Next up: your primary coding environment.
%
% Visual Studio Code is widely adopted in the industry, especially for Python and ML work. Let’s power it up with some shortcuts and features.
%
% CTRL+X: Delete a line instantly—no selection needed.
%
% CTRL+/: Comment or uncomment lines in one keystroke.
%
% CTRL+SHIFT+P: Opens the command palette—your gateway to any VS Code feature.
%
% CTRL+P: Jump to any file by typing a few letters.
%
% Multiple cursors: Hold ALT+Click to place multiple cursors and edit multiple places at once, perfect for renaming variables or adjusting repetitive lines.
%
% Mastering these shortcuts means less time navigating and more time coding.
%%% VOICEOVER OFF
\begin{frame}{VS Code Essentials}
\begin{itemize}
\item \keys{Ctrl+X}: Delete line
\item \keys{Ctrl+/}: Toggle comments
\item \keys{Ctrl+Shift+P}: Command palette
\item \keys{Ctrl+P}: Quick file navigation
\item \keys{Alt+Click}: Multiple cursors
\end{itemize}
\end{frame}

% VS Code Video
\begin{frame}{VS Code Demo}
\centering
\IfFileExists{\VideoVSCode}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoVSCode,
  flashvars={
    source=\VideoVSCode&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% Copilot Slides (VO ~30s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Developer Experience has reached a new frontier: AI-assisted coding. GitHub Copilot suggests code completions and can even transform code snippets with natural language requests.
%
% Use CTRL+I (Copilot Edit) to highlight a block of code and describe what you want in plain English—'add error handling' or 'use a list comprehension'—and watch Copilot refactor your code. This elevates you from mechanical typing to architectural thinking.
%%% VOICEOVER OFF
\begin{frame}{AI Assistance with Copilot}
\begin{itemize}
\item Copilot: AI code suggestions
\item \keys{Ctrl+I}: Natural language refactoring
\item Less grunt work, more architecture
\end{itemize}
\end{frame}

% Copilot Video
\begin{frame}{Copilot Demo}
\centering
\IfFileExists{\VideoCopilot}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoCopilot,
  flashvars={
    source=\VideoCopilot&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% Google Colab Slides
%------------------------------------------------------------
%%% VOICEOVER ON
% Sometimes you need a quick, hosted environment to run Python code or test ML models without setting up a local environment. Google Colab provides a free, cloud-based Jupyter notebook environment with built-in GPU support for certain tasks.
%
% Tradeoffs: Colab is convenient, requires no local setup, and is great for quick experiments or teaching. However, it's limited in customization, can be slower for large datasets if they need to be repeatedly uploaded, and sessions can expire, causing a need to rerun everything. Despite these tradeoffs, Colab can be an excellent way to prototype quickly and share reproducible notebooks.
%%% VOICEOVER OFF
\begin{frame}{Google Colab}
\begin{itemize}
\item Pros:
  \begin{itemize}
    \item No local setup required
    \item Free GPU/TPU support
    \item Easy to share and collaborate
  \end{itemize}
\item Cons / Tradeoffs:
  \begin{itemize}
    \item Session timeouts require reruns
    \item Limited persistence and customization
    \item Potential slower file I/O for large datasets
  \end{itemize}
\item Ideal for rapid prototyping and teaching
\end{itemize}
\end{frame}

%------------------------------------------------------------
% GitHub Codespaces Slides
%------------------------------------------------------------
%%% VOICEOVER ON
% For a more integrated, customizable cloud development environment, consider GitHub Codespaces. It's a fully featured online dev environment running VS Code in your browser, integrated directly with your repository.
%
% Tradeoffs: While Codespaces offers a more powerful and extensible environment than Colab (with persistent dev containers, custom setups, and integrated terminal), it's not free beyond certain usage limits and may require GitHub Enterprise for extensive use. It’s perfect for standardized environments, onboarding new team members quickly, and ensuring everyone has a consistent setup.
%%% VOICEOVER OFF
\begin{frame}{GitHub Codespaces}
\begin{itemize}
\item Pros:
  \begin{itemize}
    \item Fully customizable dev environment in the cloud
    \item Integrated with GitHub repos, PRs, issues
    \item Consistent environment for team onboarding
  \end{itemize}
\item Cons / Tradeoffs:
  \begin{itemize}
    \item Cost beyond free tier
    \item Requires robust network connection
    \item Not always as fast as local development for heavy tasks
  \end{itemize}
\item Great for standardized setups and scaling dev environments
\end{itemize}
\end{frame}

%------------------------------------------------------------
% uv (Python Package Manager) Slides
%------------------------------------------------------------
%%% VOICEOVER ON
% Let's talk about a modern Python package manager written in Rust: `uv`. It's designed to provide deterministic, reproducible environments and can be an alternative to tools like pip or pipenv.
%
% With `uv`, you can:
% - Initialize a project and manage dependencies in a lockfile.
% - Achieve consistent builds across machines.
% - Potentially get performance benefits due to Rust-based internals.
%
% Still early in adoption, so tradeoffs include less community support and ecosystem maturity compared to pip or conda.
%%% VOICEOVER OFF
\begin{frame}{\texttt{uv} - A Python Package Manager in Rust}
\begin{itemize}
\item Pros:
  \begin{itemize}
    \item Deterministic dependency resolution
    \item Faster performance from Rust implementation
    \item Lockfile ensures reproducible environments
  \end{itemize}
\item Cons / Tradeoffs:
  \begin{itemize}
    \item Less widely adopted than pip/conda
    \item Smaller community and fewer online resources
    \item Might not support all Python ecosystem features yet
  \end{itemize}
\item Ideal if you value reproducibility and performance
\end{itemize}
\end{frame}

% uv usage examples
\begin{frame}[fragile]{Using \texttt{uv}}
\textbf{Installation:}
If available via a package manager (e.g., Homebrew on macOS):
\begin{minted}{bash}
brew install uv
\end{minted}

Or download binaries from the GitHub releases page.

\textbf{Initialize a project:}
\begin{minted}{bash}
cd my_project
uv init
\end{minted}

This creates a \texttt{pyproject.toml} and a \texttt{uv.lock} file.

\textbf{Adding dependencies:}
\begin{minted}{bash}
uv add requests
uv add numpy==1.21.2
\end{minted}

\textbf{Installing all dependencies:}
\begin{minted}{bash}
uv sync
\end{minted}
\end{frame}

%------------------------------------------------------------
% pipx Slides
%------------------------------------------------------------
%%% VOICEOVER ON
% Another handy tool is \texttt{pipx}, which helps you install and run Python CLI tools in isolated environments. Rather than pollute your system site-packages, pipx ensures each tool has its own virtual environment, avoiding version conflicts.
%%% VOICEOVER OFF
\begin{frame}{\texttt{pipx} - Isolated Python CLI Tools}
\begin{itemize}
\item Installs Python CLI tools in isolated venvs
\item Avoids dependency/version conflicts with system Python
\item Easy to upgrade or remove tools without breaking environments
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Using \texttt{pipx}}
\textbf{Installation:}
\begin{minted}{bash}
python3 -m pip install --user pipx
python3 -m pipx ensurepath
# Restart shell if needed
\end{minted}

\textbf{Install a CLI tool (e.g. Black):}
\begin{minted}{bash}
pipx install black
black --version
\end{minted}

\textbf{Upgrade or uninstall:}
\begin{minted}{bash}
pipx upgrade black
pipx uninstall black
\end{minted}
\end{frame}

%------------------------------------------------------------
% Environment & direnv Slides (VO ~40s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Smooth development depends on stable, isolated environments. Tools like pyenv, conda, pipx let you juggle multiple Python versions and dependencies easily. For ML projects, this prevents 'works on my machine' issues.
%
% Want to load environment variables automatically per project? Use direnv. Put environment variables in .envrc, and when you cd into your project directory, direnv loads them automatically. No more manual export commands.
%%% VOICEOVER OFF
\begin{frame}{Environment Management}
\begin{itemize}
\item pyenv/conda/pipx: Manage Python versions/deps
\item direnv: Auto-load environment variables per project
\item Consistent, reliable setups
\end{itemize}
\end{frame}

% direnv Video (VO ~30s)
\begin{frame}{Environment/direnv Demo (30s)}
\centering
\IfFileExists{\VideoDirenv}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoDirenv,
  flashvars={
    source=\VideoDirenv&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% Task & Taskfile Slides (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Now let’s automate repetitive steps. Meet Task, a modern alternative to Make. Instead of wrestling with tabs and arcane syntax, you define tasks in Taskfile.yml using YAML. Tasks can depend on each other—run task train and if setup is required, it runs automatically.
%
% This standardizes your workflow: task setup, task test, task lint, task deploy—all in one place. Combine it with a bootstrap script that installs Task on any OS, and you have a frictionless environment setup.
%%% VOICEOVER OFF
\begin{frame}{Task \& Taskfile}
\begin{itemize}
\item Taskfile.yml: YAML-based tasks
\item Dependencies for seamless workflows
\item One-stop commands for build/test/deploy
\end{itemize}
\end{frame}

\begin{frame}[fragile]{Taskfile Example}
\begin{minted}{yaml}
version: '3'
tasks:
  build:
    desc: Build the project
    cmds:
      - pip install -r requirements.txt
  test:
    desc: Run tests
    deps: [build]
    cmds:
      - pytest tests/
\end{minted}
\end{frame}

% Task Video
\begin{frame}{Task Demo}
\centering
\IfFileExists{\VideoTask}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoTask,
  flashvars={
    source=\VideoTask&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% Code Quality & pre-commit (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% Clean, consistent code matters. Use Black for formatting and Flake8 for linting to keep code style and quality in check. Integrate pre-commit hooks so every git commit triggers these checks automatically. If something’s off, the commit is stopped until fixed, ensuring quality stays high from day one.
%
% This isn’t just about aesthetics—it’s about reliability, maintainability, and ethics. Secure, readable code reduces risks and fosters trust.
%%% VOICEOVER OFF
\begin{frame}{Code Quality Automation}
\begin{itemize}
\item Black \& Flake8: style \& lint checks
\item pre-commit hooks: checks at commit time
\item High standards from the start
\end{itemize}
\end{frame}

% pre-commit Video
\begin{frame}{Code Quality Demo}
\centering
\IfFileExists{\VideoPrecommit}{%
\includemedia[
  width=0.6\linewidth,
  height=0.3375\linewidth,
  activate=pageopen,
  addresource=\VideoPrecommit,
  flashvars={
    source=\VideoPrecommit&autoPlay=true&loop=false
  }
]{}{StrobeMediaPlayback.swf}%
}{%
\fbox{\parbox{0.6\linewidth}{\centering No video available}}
}
\end{frame}

%------------------------------------------------------------
% Additional New Slide Example
%------------------------------------------------------------
\begin{frame}{New Slide Title}
\begin{itemize}
\item New point 1
\item New point 2
\item New point 3
\end{itemize}
\end{frame}

%------------------------------------------------------------
% Wrap-Up (VO ~45s)
%------------------------------------------------------------
%%% VOICEOVER ON
% With these hacks—GitHub tricks for quick edits, VS Code shortcuts for effortless navigation, Copilot for AI-driven refactoring, environment managers to keep dependencies in check, Task for workflow automation, pre-commit for code quality, plus the flexibility of Google Colab, GitHub Codespaces, and novel tools like uv—you’ve got a powerful toolkit.
%
% These tools free you from the drudgery of setup and repetitive tasks, letting you focus on building robust solutions. Master these now, and you’ll find the upcoming ML pipeline sessions much smoother. Let’s put these capabilities to use as we build and deploy real machine learning projects.
%%% VOICEOVER OFF
\begin{frame}{Your DX Superpowers}
\begin{itemize}
  \item GitHub \& GH CLI
  \item VS Code \& Copilot
  \item Google Colab \& GitHub Codespaces
  \item pyenv/conda/pipx/uv \& direnv
  \item Task \& pre-commit
\end{itemize}
\vspace{-1em}
\end{frame}

%------------------------------------------------------------
% Resources (brief ~20s)
%------------------------------------------------------------
%%% VOICEOVER ON
% For more information, here are some resources to help you get started.
% The official documentation for GitHub CLI, VS Code keybindings, and GitHub Copilot provide in-depth guides.
% Additionally, check out docs for Colab, Codespaces, pyenv, conda, pipx, uv, direnv, Task, and pre-commit.
% In the next sessions, as we tackle automation, data preparation, model training, and deployment, you’ll have the edge these hacks provide.
%%% VOICEOVER OFF
\begin{frame}{Resources \& Next Steps}
\begin{itemize}
\item \href{https://cli.github.com/}{GitHub CLI Docs}
\item \href{https://code.visualstudio.com/docs}{VS Code Documentation}
\item \href{https://github.com/features/copilot}{GitHub Copilot Info}
\item \href{https://research.google.com/colaboratory/}{Google Colab Docs}
\item \href{https://github.com/features/codespaces}{GitHub Codespaces}
\item pyenv/conda/pipx/uv/direnv/task/pre-commit docs
\end{itemize}\label{lastpage}
\end{frame}

\end{document}
